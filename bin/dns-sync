#!/usr/bin/perl -I lib/

use strict;
use warnings;

use Getopt::Long::Descriptive qw(describe_options);
use Module::Pluggable search_path => ['DnsSync::Provider'], sub_name => 'providers', require => 1;

use DnsSync::RecordSet qw(compute_record_set_delta apply_deltas);
use DnsSync::Utils     qw(verbose set_verbosity);

my ($cli) = describe_options(
	'dns-sync %o',
	[ 'verbose|v', 'Increases logging verbosity', ],
	[ 'wait', 'Prevent exit until changes have propogated to DNS servers', ],
	[ 'origin=s', 'Use specified DNS zone origin for write operations. This allows a record set to be transposed from one origin to another when source and target origins differ. Note that some providers force the origin to a particular value based on existing data. and will complain if this is set to a different value' ],
	[ 'delete', 'Removes records from destination which do not also exist in source. By default will overwrite existing items, but never delete them if there is no replacement' ],
	[ 'managed-set|managed=s', 'Uses a third DNS storage mechanism (eg, file, route53) to maintain a list of records which are being managed by dns-sync. Subsequent runs with --delete flag set will ONLY delete records which existing in the managed set, thus allowing DNS sync to operate in conjunction with some outside system (or manual changes)' ],
	#[ 'exclude=s', 'Filter for records to ignore from sync' ],
	#[ 'include=s', 'Filter for records to include in sync. If unspecified, includes everything except those explicitly mentioned by --exclude' ],
);
set_verbosity(1) if $cli->{verbose};

my %CMD_HANDLERS = (
	sync => \&cmd_sync,
);

exit main();

sub main {
	my ($cmd) = shift @ARGV;

	die "Must specify command name" unless $cmd;

	if($CMD_HANDLERS{$cmd}) {
		$CMD_HANDLERS{$cmd}->();
		return 0;
	} else {
		print STDERR "Invalid command: $cmd";
		return 255;
	}
}

# Command which syncs two DNS providers by finding delta between source and target, and then applies
# delta to the target
sub cmd_sync {
	my ($sourceUri, $targetUri) = @ARGV;
	die "Sync command expects 2 positional arguments: source and target" unless $sourceUri && $targetUri;

	# Find the providers for the source and dest
	my $source  = get_provider_for_uri($sourceUri, 'source');
	my $target  = get_provider_for_uri($targetUri, 'target');
	my $managed = get_provider_for_uri($cli->{managed_set}, 'managed-set');

	# Fetch data for managed set
	my $managedData;
	if($managed) {
		$managedData = $managed->can('get_records')->($cli->{managed_set}, {
			allowNonExistent => 1,
		});
	}

	# Compute delta for target
	my $desired  = $source->can('get_records')->($sourceUri);
	my $existing = $target->can('get_records')->($targetUri, { allowNonExistent => 1 });
	my $delta    = compute_record_set_delta($existing->{records}, $desired->{records}, {
		managed => $managedData->{records},
	});
	$delta->{deletions} = [] unless $cli->{delete};

	# Perform sync
	my %writeArgs = (
		wait     => $cli->{wait},
		origin   => $cli->{origin},
		existing => $existing,
	);
	if(scalar @{$delta->{deletions}} == 0 and scalar @{$delta->{upserts}} == 0) {
		print "No updates required\n";
	} else {
		verbose "Writing new records to target";
		$target->can('write_delta')->($targetUri, $delta, \%writeArgs);
	}

	# Update managed set for use next run
	if($managed) {
		verbose "Updating managed set";
		$managed->can('set_records')->($cli->{managed_set}, {
			origin  => $cli->{origin} || $managedData->{origin},
			ttl     => $managedData->{origin},
			records => $desired->{records},
		}, \%writeArgs);
	}

	return 0;
}

sub get_provider_for_uri {
	my ($uri, $label) = @_;

	return unless $uri;

	my @providers = providers();
  @providers = grep { $_->can('can_handle')->($uri) } @providers;
	my $count = @providers;
	if($count == 0) {
		die "No DNS provider found for which can handle '$uri' (for $label)";
	} elsif ($count > 1) {
		die "$label '$uri' is ambigious and can be handled by multiple DNS implementations: " . join(',', @providers);
	} else {
		return $providers[0];
	}
}
