#!/usr/bin/env perl

use strict;
use warnings;

use Data::Compare;
use File::Temp qw(tempfile);
use Getopt::Long::Descriptive qw(describe_options);
use JSON::XS qw(decode_json encode_json);
use Try::Tiny;

use Data::Dumper;

my ($cli) = describe_options(
	'route53-sync %o',
	[ 'zone|z=s', 'Route 53 Zone ID', { required => 1 } ],
	[ 'directory|dir|d=s', 'Path to directory containing JSON files to sync', ],
	[ 'verbose|v', 'Increases logging verbosity', ],
	[ 'wait', 'Prevent exit until change has propogated to DNS servers', ],
);

exit main();

sub main {
	die "Directory $cli->{directory} does not exist" unless -d $cli->{directory};

	my @desired  = load_zone_files($cli->{directory});
	my $aws = list_aws_records($cli->{zone});
	my @existing = @{$aws->{records}};
	my @updates  = compute_required_updates(\@existing, \@desired);

	if(scalar(@updates) == 0) {
		print "No updates required\n";
		return 0;
	}

	update_aws(\@updates, $aws->{origin});
	return 0;
}

# Loads list of existing existing records using AWS CLI tool
# Returns { records => [], origin => string } hash
sub list_aws_records {
	my ($zoneId) = @_;

	# Fetch AWS meta data
	verbose("Fetching Route53 zone meta data...\n");
	my $zone = `aws route53 get-hosted-zone --id ${zoneId}`;
	die "Failed to fetch Route53 zone meta data" unless ($? >> 8 == 0);
	$zone = decode_json($zone);
	my $origin = $zone->{HostedZone}{Name};

	# Fetch AWS Records
  verbose("Listing existing DNS records...\n");
	my @awsRecords;
	my $existing = `aws route53 list-resource-record-sets --hosted-zone-id $zoneId`;
	die "Failed to list Route53 records" unless ($? >> 8 == 0);
	$existing = decode_json($existing);
	push @awsRecords, @{$existing->{ResourceRecordSets}};
	while($existing->{NextToken}) {
	  $existing = `aws route53 list-resource-record-sets --hosted-zone-id $zoneId --starting-token $existing->{NextToken}`;
	  die "Failed to list Route53 records" unless ($? >> 8 != 0);
		$existing = decode_json($existing);
		push @awsRecords, @{$existing->{ResourceRecordSets}};
	}

	# Convert from AWS record format to zone file object format
	my @results;
	for my $rec (@awsRecords) {
		for my $val (@{$rec->{ResourceRecords}}) {
			my $label = substr($rec->{Name}, 0, -length($origin)-1);
			$label = '@' if length($label) == 0;
			push @results, {
				label => $label,
				ttl   => $rec->{TTL},
				class => 'IN',
				type  => $rec->{Type},
				data  => $val->{Value},
			};
		}
	}

	return { records => \@results, origin => $origin };
}

sub update_aws {
	my ($records, $origin) = @_;


	# Convert from list of zone file style record objects to AWS API objects
	my @updates;
	my $grouped = group_records($records);
	for my $n (keys %$grouped) {
		for my $t (keys %{$grouped->{$n}}) {
			my $ttl = 999999999;
			my @values;

			for my $r (@{$grouped->{$n}{$t}}) {
				$ttl = $r->{ttl} if $r->{ttl} < $ttl;
				push @values, { Value => $r->{data} };
			}

			push @updates, {
				Name            => "${n}.${origin}",
				Type            => $t,
				TTL             => $ttl,
				ResourceRecords => \@values,
			};
		}
	}

	my $changeCount = scalar(@$records);
	print "Performing AWS update ($changeCount record" . ($changeCount == 1 ? '' : 's') . " to change)\n";

	my @changes = map { { Action => "UPSERT", "ResourceRecordSet" => $_ } } @updates;
	my $awsUpdate = {
		Comment => "route53-sync update",
		Changes => \@changes,
	};
	my $updateJson = encode_json($awsUpdate);

	my ($fh, $updateFilename) = tempfile("route53-sync-XXXXXXXX", DIR => '/tmp');
	print $fh $updateJson;
	close($fh);

	# Make change and wait for completion
	my $out = `aws route53 change-resource-record-sets --hosted-zone-id $cli->{zone} --change-batch file://${updateFilename}`;
	my $retcode = $?;
	unlink $fh;
  exit ($retcode >> 8) if ($retcode >> 8 != 0);

	if($cli->{wait}) {
		my $change = decode_json($out);
		verbose("Waiting for Route53 update '$change->{ChangeInfo}{Id}' to complete\n");
		my $elapsed = 20;
		sleep($elapsed);
		while($change->{ChangeInfo}{Status} ne "INSYNC") {
			verbose("Waiting for Route53 update '$change->{ChangeInfo}{Id}' to complete (elapsed: ${elapsed}s)\n");
			sleep(5);
			$elapsed += 5;
			$out = `aws route53 get-change --id $change->{ChangeInfo}{Id}`;
			exit ($? >> 8) if ($? >> 8 != 0);
			$change = decode_json($out);
		}
	}

	print "Update complete\n";
}

# Loads desired records from zone files within directory
# Returns list of objects of the form:
# { label,      ttl, class, type, data }
#   example.com 600  IN     A     127.0.0.1
sub load_zone_files {
	my ($directory) = @_;
	opendir(my $dh, $directory);
	my @files = readdir($dh);
	closedir($dh);

	my @results;

	foreach my $file (@files) {
		next unless $file =~ /.+\.zone$/;
		my $path = "$cli->{directory}/${file}";

		open(my $fh, '<', $path) or die $!;
		my $raw = do { local $/; <$fh> };
		close($fh);

		my @lines = split(/\n/, $raw);

		foreach my $line (@lines) {
			my ($label, $ttl, $class, $type, $data) = split(/\t/, $line);
			die "Only Internet (aka: IN class) records are supported, got: $label $ttl $class $type $data in file $file" unless $class eq "IN";
			die "TXT record data must be wrapped in quotes" if $type eq "TXT" and $data !~ /^"[^"]+"$/;
			push @results, { label => $label, ttl => $ttl + 0, class => $class, type => $type, data => $data };
		}
	}

	return @results;
}

# Computes list of records which require creation/update
sub compute_required_updates {
	my ($existing, $desired) = @_;

	my $existingMap = group_records($existing);
	my $desiredMap  = group_records($desired);

	my @results;
  for my $n (keys %$desiredMap) {
		for my $t (keys %{$desiredMap->{$n}}) {

			my $d = $desiredMap->{$n}{$t};
			my $e = $existingMap->{$n}{$t};

			push @results, @$d unless Compare($d, $e);

		}
	}

	return @results;
}

# Helper which groups a list of DNS records into map of $map->{name}{type} => array of records
sub group_records {
	my ($records) = @_;

	my $map = {};
	push @{$map->{$_->{label}}{$_->{type}}}, $_ foreach @$records;

	for my $n (keys %$map) {
		for my $t (keys %{$map->{$n}}) {
			my @list = sort { $a->{data} cmp $b->{data} } @{$map->{$n}{$t}};
			$map->{$n}{$t} = \@list;
		}
	}

	return $map;
}

sub verbose {
	return unless $cli->{verbose};
	print @_;
}
